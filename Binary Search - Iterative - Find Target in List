'''
## Task: find the index of the target value in a list in O(log n) time. 

IOEC:
Input: list of integers, target integer value
Output: integer representing the index. so output can be 0 and higher
Edgcases:
# if target is not in the list --> return None
# if list is empty --> return None

Constraints on time complexity and memory (space) complexity? None

## Match:
binary search problem. keep cutting list in half. time complexity O(log n)

## Plan:
create a left pointer at the 0th index
create a right pointer at the last index in the list

while the right pointer index is greater than the left keep going:
get the middle index by subtracting the last from the first and dividing by 2. floor it incase list is odd
ask if the target value is at the middle index. 
if it is return that index as the answer
if it is not:
    check if the target is greater than the items at that middle index.
        if the target is greater than the middle value:
            the middle index becomes the left pointer
		if the targert is lower that the middle value:
            the middle becomes the right pointer	
'''

def binary_search(lst, target):
	left_index, right_index = 0, len(lst) -1
	while right_index >= left_index:
		middle_index = (right_index + left_index)//2
		if lst[middle_index] == target:
			return middle_index
		elif target > lst[middle_index]:
			left_index = middle_index + 1
		else:
			right_index = middle_index - 1
	return -1


#test cases
lst = [1, 3, 5, 7, 9, 11, 13, 15] 
target = 11
print(binary_search(lst, target)) #return 5

lst = [1, 3, 5, 7, 9, 11, 13, 15]
target = 12
print(binary_search(lst, target)) #return -1

lst = []
target = 12
print(binary_search(lst, target)) #return -1

lst = [1, 3, 5, 7, 9, 11, 13, 15]
target = 1
print(binary_search(lst, target)) #return 0

#Time complexity: O(log n) Logarithmic
#Space complexity: O(1) Constant
